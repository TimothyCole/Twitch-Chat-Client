{"dependencies":[{"name":"./utils","loc":{"line":1,"column":16}}],"generated":{"js":"var _ = require(\"./utils\");\r\n\r\n// Enable followers-only mode on a channel..\r\nfunction followersonly(channel, minutes) {\r\n    channel = _.channel(channel);\r\n    minutes = _.get(minutes, 30);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), channel, `/followers ${minutes}`, (resolve, reject) => {\r\n        // Received _promiseFollowers event, resolve or reject..\r\n        this.once(\"_promiseFollowers\", (err) => {\r\n            if (!err) { resolve([channel, ~~minutes]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\n// Disable followers-only mode on a channel..\r\nfunction followersonlyoff(channel) {\r\n    channel = _.channel(channel);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), channel, \"/followersoff\", (resolve, reject) => {\r\n        // Received _promiseFollowersoff event, resolve or reject..\r\n        this.once(\"_promiseFollowersoff\", (err) => {\r\n            if (!err) { resolve([channel]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\n// Leave a channel..\r\nfunction part(channel) {\r\n    channel = _.channel(channel);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), null, `PART ${channel}`, (resolve, reject) => {\r\n        // Received _promisePart event, resolve or reject..\r\n        this.once(\"_promisePart\", (err) => {\r\n            if (!err) { resolve([channel]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\n// Enable R9KBeta mode on a channel..\r\nfunction r9kbeta(channel) {\r\n    channel = _.channel(channel);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), channel, \"/r9kbeta\", (resolve, reject) => {\r\n        // Received _promiseR9kbeta event, resolve or reject..\r\n        this.once(\"_promiseR9kbeta\", (err) => {\r\n            if (!err) { resolve([channel]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\n// Disable R9KBeta mode on a channel..\r\nfunction r9kbetaoff(channel) {\r\n    channel = _.channel(channel);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), channel, \"/r9kbetaoff\", (resolve, reject) => {\r\n        // Received _promiseR9kbetaoff event, resolve or reject..\r\n        this.once(\"_promiseR9kbetaoff\", (err) => {\r\n            if (!err) { resolve([channel]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\n// Enable slow mode on a channel..\r\nfunction slow(channel, seconds) {\r\n    channel = _.channel(channel);\r\n    seconds = _.get(seconds, 300);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), channel, `/slow ${seconds}`, (resolve, reject) => {\r\n        // Received _promiseSlow event, resolve or reject..\r\n        this.once(\"_promiseSlow\", (err) => {\r\n            if (!err) { resolve([channel, ~~seconds]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\n// Disable slow mode on a channel..\r\nfunction slowoff(channel) {\r\n    channel = _.channel(channel);\r\n\r\n    // Send the command to the server and race the Promise against a delay..\r\n    return this._sendCommand(this._getPromiseDelay(), channel, \"/slowoff\", (resolve, reject) => {\r\n        // Received _promiseSlowoff event, resolve or reject..\r\n        this.once(\"_promiseSlowoff\", (err) => {\r\n            if (!err) { resolve([channel]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n}\r\n\r\nmodule.exports = {\r\n    // Send action message (/me <message>) on a channel..\r\n    action: function action(channel, message) {\r\n        channel = _.channel(channel);\r\n        message = `\\u0001ACTION ${message}\\u0001`;\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendMessage(this._getPromiseDelay(), channel, message, (resolve, reject) => {\r\n            // At this time, there is no possible way to detect if a message has been sent has been eaten\r\n            // by the server, so we can only resolve the Promise.\r\n            resolve([channel, message]);\r\n        });\r\n    },\r\n\r\n    // Ban username on channel..\r\n    ban: function ban(channel, username, reason) {\r\n        channel = _.channel(channel);\r\n        username = _.username(username);\r\n        reason = _.get(reason, \"\");\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, `/ban ${username} ${reason}`, (resolve, reject) => {\r\n            // Received _promiseBan event, resolve or reject..\r\n            this.once(\"_promiseBan\", (err) => {\r\n                if (!err) { resolve([channel, username, reason]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Clear all messages on a channel..\r\n    clear: function clear(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, \"/clear\", (resolve, reject) => {\r\n            // Received _promiseClear event, resolve or reject..\r\n            this.once(\"_promiseClear\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Change the color of your username..\r\n    color: function color(channel, newColor) {\r\n        newColor = _.get(newColor, channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), \"#tmijs\", `/color ${newColor}`, (resolve, reject) => {\r\n            // Received _promiseColor event, resolve or reject..\r\n            this.once(\"_promiseColor\", (err) => {\r\n                if (!err) { resolve([newColor]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Run commercial on a channel for X seconds..\r\n    commercial: function commercial(channel, seconds) {\r\n        channel = _.channel(channel);\r\n        seconds = _.get(seconds, 30);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, `/commercial ${seconds}`, (resolve, reject) => {\r\n            // Received _promiseCommercial event, resolve or reject..\r\n            this.once(\"_promiseCommercial\", (err) => {\r\n                if (!err) { resolve([channel, ~~seconds]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Enable emote-only mode on a channel..\r\n    emoteonly: function emoteonly(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, \"/emoteonly\", (resolve, reject) => {\r\n            // Received _promiseEmoteonly event, resolve or reject..\r\n            this.once(\"_promiseEmoteonly\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Disable emote-only mode on a channel..\r\n    emoteonlyoff: function emoteonlyoff(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, \"/emoteonlyoff\", (resolve, reject) => {\r\n            // Received _promiseEmoteonlyoff event, resolve or reject..\r\n            this.once(\"_promiseEmoteonlyoff\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Enable followers-only mode on a channel..\r\n    followersonly: followersonly,\r\n\r\n    // Alias for followersonly()..\r\n    followersmode: followersonly,\r\n\r\n    // Disable followers-only mode on a channel..\r\n    followersonlyoff: followersonlyoff,\r\n\r\n    // Alias for followersonlyoff()..\r\n    followersmodeoff: followersonlyoff,\r\n\r\n    // Host a channel..\r\n    host: function host(channel, target) {\r\n        channel = _.channel(channel);\r\n        target = _.username(target);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(2000, channel, `/host ${target}`, (resolve, reject) => {\r\n            // Received _promiseHost event, resolve or reject..\r\n            this.once(\"_promiseHost\", (err, remaining) => {\r\n                if (!err) { resolve([channel, target, ~~remaining]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Join a channel..\r\n    join: function join(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), null, `JOIN ${channel}`, (resolve, reject) => {\r\n            // Received _promiseJoin event, resolve or reject..\r\n            this.once(\"_promiseJoin\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Mod username on channel..\r\n    mod: function mod(channel, username) {\r\n        channel = _.channel(channel);\r\n        username = _.username(username);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, `/mod ${username}`, (resolve, reject) => {\r\n            // Received _promiseMod event, resolve or reject..\r\n            this.once(\"_promiseMod\", (err) => {\r\n                if (!err) { resolve([channel, username]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Get list of mods on a channel..\r\n    mods: function mods(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, \"/mods\", (resolve, reject) => {\r\n            // Received _promiseMods event, resolve or reject..\r\n            this.once(\"_promiseMods\", (err, mods) => {\r\n                if (!err) {\r\n                    // Update the internal list of moderators..\r\n                    mods.forEach((username) => {\r\n                        if (!this.moderators[channel]) { this.moderators[channel] = []; }\r\n                        if (this.moderators[channel].indexOf(username) < 0) { this.moderators[channel].push(username); }\r\n                    });\r\n                    resolve(mods);\r\n                } else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Leave a channel..\r\n    part: part,\r\n\r\n    // Alias for part()..\r\n    leave: part,\r\n\r\n    // Send a ping to the server..\r\n    ping: function ping() {\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), null, \"PING\", (resolve, reject) => {\r\n            // Update the internal ping timeout check interval..\r\n            this.latency = new Date();\r\n            this.pingTimeout = setTimeout(() => {\r\n                if (this.ws !== null) {\r\n                    this.wasCloseCalled = false;\r\n                    this.log.error(\"Ping timeout.\");\r\n                    this.ws.close();\r\n\r\n                    clearInterval(this.pingLoop);\r\n                    clearTimeout(this.pingTimeout);\r\n                }\r\n            }, _.get(this.opts.connection.timeout, 9999));\r\n\r\n            // Received _promisePing event, resolve or reject..\r\n            this.once(\"_promisePing\", (latency) => { resolve([parseFloat(latency)]); });\r\n        });\r\n    },\r\n\r\n    // Enable R9KBeta mode on a channel..\r\n    r9kbeta: r9kbeta,\r\n\r\n    // Alias for r9kbeta()..\r\n    r9kmode: r9kbeta,\r\n\r\n    // Disable R9KBeta mode on a channel..\r\n    r9kbetaoff: r9kbetaoff,\r\n\r\n    // Alias for r9kbetaoff()..\r\n    r9kmodeoff: r9kbetaoff,\r\n\r\n    // Send a raw message to the server..\r\n    raw: function raw(message) {\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), null, message, (resolve, reject) => {\r\n            resolve([message]);\r\n        });\r\n    },\r\n\r\n    // Send a message on a channel..\r\n    say: function say(channel, message) {\r\n        channel = _.channel(channel);\r\n\r\n        if ((message.startsWith(\".\") && !message.startsWith(\"..\")) || message.startsWith(\"/\") || message.startsWith(\"\\\\\")) {\r\n            // Check if the message is an action message..\r\n            if (message.substr(1, 3) === \"me \") {\r\n                return this.action(channel, message.substr(4));\r\n            }\r\n            else {\r\n                // Send the command to the server and race the Promise against a delay..\r\n                return this._sendCommand(this._getPromiseDelay(), channel, message, (resolve, reject) => {\r\n                    // At this time, there is no possible way to detect if a message has been sent has been eaten\r\n                    // by the server, so we can only resolve the Promise.\r\n                    resolve([channel, message]);\r\n                });\r\n            }\r\n        }\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendMessage(this._getPromiseDelay(), channel, message, (resolve, reject) => {\r\n            // At this time, there is no possible way to detect if a message has been sent has been eaten\r\n            // by the server, so we can only resolve the Promise.\r\n            resolve([channel, message]);\r\n        });\r\n    },\r\n\r\n    // Enable slow mode on a channel..\r\n    slow: slow,\r\n\r\n    // Alias for slow()..\r\n    slowmode: slow,\r\n\r\n    // Disable slow mode on a channel..\r\n    slowoff: slowoff,\r\n\r\n    // Alias for slowoff()..\r\n    slowmodeoff: slowoff,\r\n\r\n    // Enable subscribers mode on a channel..\r\n    subscribers: function subscribers(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, \"/subscribers\", (resolve, reject) => {\r\n            // Received _promiseSubscribers event, resolve or reject..\r\n            this.once(\"_promiseSubscribers\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Disable subscribers mode on a channel..\r\n    subscribersoff: function subscribersoff(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, \"/subscribersoff\", (resolve, reject) => {\r\n            // Received _promiseSubscribersoff event, resolve or reject..\r\n            this.once(\"_promiseSubscribersoff\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Timeout username on channel for X seconds..\r\n    timeout: function timeout(channel, username, seconds, reason) {\r\n        channel = _.channel(channel);\r\n        username = _.username(username);\r\n\r\n        if (!_.isNull(seconds) && !_.isInteger(seconds)) {\r\n            reason = seconds;\r\n            seconds = 300;\r\n        }\r\n\r\n        seconds = _.get(seconds, 300);\r\n        reason = _.get(reason, \"\");\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, `/timeout ${username} ${seconds} ${reason}`, (resolve, reject) => {\r\n            // Received _promiseTimeout event, resolve or reject..\r\n            this.once(\"_promiseTimeout\", (err) => {\r\n                if (!err) { resolve([channel, username, ~~seconds, reason]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Unban username on channel..\r\n    unban: function unban(channel, username) {\r\n        channel = _.channel(channel);\r\n        username = _.username(username);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, `/unban ${username}`, (resolve, reject) => {\r\n            // Received _promiseUnban event, resolve or reject..\r\n            this.once(\"_promiseUnban\", (err) => {\r\n                if (!err) { resolve([channel, username]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // End the current hosting..\r\n    unhost: function unhost(channel) {\r\n        channel = _.channel(channel);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(2000, channel, \"/unhost\", (resolve, reject) => {\r\n            // Received _promiseUnhost event, resolve or reject..\r\n            this.once(\"_promiseUnhost\", (err) => {\r\n                if (!err) { resolve([channel]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Unmod username on channel..\r\n    unmod: function unmod(channel, username) {\r\n        channel = _.channel(channel);\r\n        username = _.username(username);\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), channel, `/unmod ${username}`, (resolve, reject) => {\r\n            // Received _promiseUnmod event, resolve or reject..\r\n            this.once(\"_promiseUnmod\", (err) => {\r\n                if (!err) { resolve([channel, username]); }\r\n                else { reject(err); }\r\n            });\r\n        });\r\n    },\r\n\r\n    // Send an whisper message to a user..\r\n    whisper: function whisper(username, message) {\r\n        username = _.username(username);\r\n\r\n        // The server will not send a whisper to the account that sent it.\r\n        if (username === this.getUsername()) {\r\n            return Promise.reject(\"Cannot send a whisper to the same account.\");\r\n        }\r\n\r\n        // Send the command to the server and race the Promise against a delay..\r\n        return this._sendCommand(this._getPromiseDelay(), \"#tmijs\", `/w ${username} ${message}`, (resolve, reject) => {\r\n            var from = _.channel(username),\r\n                userstate = _.merge({\r\n                        \"message-type\": \"whisper\",\r\n                        \"message-id\": null,\r\n                        \"thread-id\": null,\r\n                        username: this.getUsername()\r\n                    }, this.globaluserstate);\r\n\r\n            // Emit for both, whisper and message..\r\n            this.emits([\"whisper\", \"message\"], [\r\n                [from, userstate, message, true],\r\n                [from, userstate, message, true]\r\n            ]);\r\n\r\n            // At this time, there is no possible way to detect if a message has been sent has been eaten\r\n            // by the server, so we can only resolve the Promise.\r\n            resolve([username, message]);\r\n        });\r\n    }\r\n}\r\n"},"hash":"ff477fc1692cae08dac792f0a5769e85"}