{"dependencies":[{"name":"./api","loc":{"line":1,"column":18}},{"name":"./commands","loc":{"line":2,"column":23}},{"name":"./events","loc":{"line":3,"column":27}},{"name":"./logger","loc":{"line":4,"column":21}},{"name":"./parser","loc":{"line":5,"column":20}},{"name":"./timer","loc":{"line":6,"column":20}},{"name":"ws","loc":{"line":7,"column":60}},{"name":"./utils","loc":{"line":8,"column":16}}],"generated":{"js":"var global = (1,eval)(\"this\");\nvar api = require(\"./api\");\r\nvar commands = require(\"./commands\");\r\nvar eventEmitter = require(\"./events\").EventEmitter;\r\nvar logger = require(\"./logger\");\r\nvar parse = require(\"./parser\");\r\nvar timer = require(\"./timer\");\r\nvar ws = global.WebSocket || global.MozWebSocket || require(\"ws\");\r\nvar _ = require(\"./utils\");\r\n\r\n// Client instance..\r\nvar client = function client(opts) {\r\n    if (this instanceof client === false) { return new client(opts); }\r\n    this.setMaxListeners(0);\r\n\r\n    this.opts = _.get(opts, {});\r\n    this.opts.channels = this.opts.channels || [];\r\n    this.opts.connection = this.opts.connection || {};\r\n    this.opts.identity = this.opts.identity || {};\r\n    this.opts.options = this.opts.options || {};\r\n\r\n    this.clientId = _.get(this.opts.options.clientId, null);\r\n\r\n    this.maxReconnectAttempts = _.get(this.opts.connection.maxReconnectAttempts, Infinity);\r\n    this.maxReconnectInterval = _.get(this.opts.connection.maxReconnectInterval, 30000);\r\n    this.reconnect = _.get(this.opts.connection.reconnect, false);\r\n    this.reconnectDecay = _.get(this.opts.connection.reconnectDecay, 1.5);\r\n    this.reconnectInterval = _.get(this.opts.connection.reconnectInterval, 1000);\r\n\r\n    this.reconnecting = false;\r\n    this.reconnections = 0;\r\n    this.reconnectTimer = this.reconnectInterval;\r\n\r\n    this.secure = _.get(this.opts.connection.secure, false);\r\n\r\n    // Raw data and object for emote-sets..\r\n    this.emotes = \"\";\r\n    this.emotesets = {};\r\n\r\n    this.channels = [];\r\n    this.currentLatency = 0;\r\n    this.globaluserstate = {};\r\n    this.lastJoined = \"\";\r\n    this.latency = new Date();\r\n    this.moderators = {};\r\n    this.pingLoop = null;\r\n    this.pingTimeout = null;\r\n    this.reason = \"\";\r\n    this.username = \"\";\r\n    this.userstate = {};\r\n    this.wasCloseCalled = false;\r\n    this.ws = null;\r\n\r\n    // Create the logger..\r\n    var level = \"error\";\r\n    if (this.opts.options.debug) { level = \"info\"; }\r\n    this.log = this.opts.logger || logger;\r\n\r\n    try { logger.setLevel(level); } catch(e) {};\r\n\r\n    // Format the channel names..\r\n    this.opts.channels.forEach(function(part, index, theArray) {\r\n        theArray[index] = _.channel(part);\r\n    });\r\n\r\n    eventEmitter.call(this);\r\n}\r\n\r\n_.inherits(client, eventEmitter);\r\n\r\nclient.prototype.api = api;\r\n\r\n// Put all commands in prototype..\r\nfor(var methodName in commands) {\r\n    client.prototype[methodName] = commands[methodName];\r\n}\r\n\r\n// Handle parsed chat server message..\r\nclient.prototype.handleMessage = function handleMessage(message) {\r\n    if (!_.isNull(message)) {\r\n        var channel = _.channel(_.get(message.params[0], null));\r\n        var msg = _.get(message.params[1], null);\r\n        var msgid = _.get(message.tags[\"msg-id\"], null);\r\n\r\n        // Parse badges and emotes..\r\n        message.tags = parse.badges(parse.emotes(message.tags));\r\n\r\n        // Transform IRCv3 tags..\r\n        if (message.tags) {\r\n            for(var key in message.tags) {\r\n                if (key !== \"emote-sets\" && key !== \"ban-duration\" && key !== \"bits\") {\r\n                    if (_.isBoolean(message.tags[key])) { message.tags[key] = null; }\r\n                    else if (message.tags[key] === \"1\") { message.tags[key] = true; }\r\n                    else if (message.tags[key] === \"0\") { message.tags[key] = false; }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Messages with no prefix..\r\n        if (_.isNull(message.prefix)) {\r\n            switch(message.command) {\r\n                // Received PING from server..\r\n                case \"PING\":\r\n                    this.emit(\"ping\");\r\n                    if (!_.isNull(this.ws) && this.ws.readyState !== 2 && this.ws.readyState !== 3) {\r\n                        this.ws.send(\"PONG\");\r\n                    }\r\n                    break;\r\n\r\n                // Received PONG from server, return current latency..\r\n                case \"PONG\":\r\n                    var currDate = new Date();\r\n                    this.currentLatency = (currDate.getTime() - this.latency.getTime()) / 1000;\r\n                    this.emits([\"pong\", \"_promisePing\"], [[this.currentLatency], [this.currentLatency]]);\r\n\r\n                    clearTimeout(this.pingTimeout);\r\n                    break;\r\n\r\n                default:\r\n                    this.log.warn(`Could not parse message with no prefix:\\n${JSON.stringify(message, null, 4)}`);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Messages with \"tmi.twitch.tv\" as a prefix..\r\n        else if (message.prefix === \"tmi.twitch.tv\") {\r\n            switch(message.command) {\r\n                case \"002\":\r\n                case \"003\":\r\n                case \"004\":\r\n                case \"375\":\r\n                case \"376\":\r\n                case \"CAP\":\r\n                    break;\r\n\r\n                // Retrieve username from server..\r\n                case \"001\":\r\n                    this.username = message.params[0];\r\n                    break;\r\n\r\n                // Connected to server..\r\n                case \"372\":\r\n                    this.log.info(\"Connected to server.\");\r\n                    this.userstate[\"#tmijs\"] = {};\r\n                    this.emits([\"connected\", \"_promiseConnect\"], [[this.server, this.port], [null]]);\r\n                    this.reconnections = 0;\r\n                    this.reconnectTimer = this.reconnectInterval;\r\n\r\n                    // Set an internal ping timeout check interval..\r\n                    this.pingLoop = setInterval(() => {\r\n                        // Make sure the connection is opened before sending the message..\r\n                        if (!_.isNull(this.ws) && this.ws.readyState !== 2 && this.ws.readyState !== 3) {\r\n                            this.ws.send(\"PING\");\r\n                        }\r\n                        this.latency = new Date();\r\n                        this.pingTimeout = setTimeout(() => {\r\n                            if (!_.isNull(this.ws)) {\r\n                                this.wasCloseCalled = false;\r\n                                this.log.error(\"Ping timeout.\");\r\n                                this.ws.close();\r\n\r\n                                clearInterval(this.pingLoop);\r\n                                clearTimeout(this.pingTimeout);\r\n                            }\r\n                        }, _.get(this.opts.connection.timeout, 9999));\r\n                    }, 60000);\r\n\r\n                    // Join all the channels from configuration with a 2 seconds interval..\r\n                    var joinQueue = new timer.queue(2000);\r\n                    var joinChannels = _.union(this.opts.channels, this.channels);\r\n                    this.channels = [];\r\n\r\n                    for (var i = 0; i < joinChannels.length; i++) {\r\n                        var self = this;\r\n                        joinQueue.add(function(i) {\r\n                            if (!_.isNull(self.ws) && self.ws.readyState !== 2 && self.ws.readyState !== 3) {\r\n                                self.ws.send(`JOIN ${_.channel(joinChannels[i])}`);\r\n                            }\r\n                        }.bind(this, i))\r\n                    }\r\n\r\n                    joinQueue.run();\r\n                    break;\r\n\r\n                // https://github.com/justintv/Twitch-API/blob/master/chat/capabilities.md#notice\r\n                case \"NOTICE\":\r\n                    switch(msgid) {\r\n                        // This room is now in subscribers-only mode.\r\n                        case \"subs_on\":\r\n                            this.log.info(`[${channel}] This room is now in subscribers-only mode.`);\r\n                            this.emits([\"subscriber\", \"subscribers\", \"_promiseSubscribers\"], [[channel, true], [channel, true], [null]]);\r\n                            break;\r\n\r\n                        // This room is no longer in subscribers-only mode.\r\n                        case \"subs_off\":\r\n                            this.log.info(`[${channel}] This room is no longer in subscribers-only mode.`);\r\n                            this.emits([\"subscriber\", \"subscribers\", \"_promiseSubscribersoff\"], [[channel, false], [channel, false], [null]]);\r\n                            break;\r\n\r\n                        // This room is now in emote-only mode.\r\n                        case \"emote_only_on\":\r\n                            this.log.info(`[${channel}] This room is now in emote-only mode.`);\r\n                            this.emits([\"emoteonly\", \"_promiseEmoteonly\"], [[channel, true], [null]]);\r\n                            break;\r\n\r\n                        // This room is no longer in emote-only mode.\r\n                        case \"emote_only_off\":\r\n                            this.log.info(`[${channel}] This room is no longer in emote-only mode.`);\r\n                            this.emits([\"emoteonly\", \"_promiseEmoteonlyoff\"], [[channel, false], [null]]);\r\n                            break;\r\n\r\n                        // Do not handle slow_on/off here, listen to the ROOMSTATE notice instead as it returns the delay.\r\n                        case \"slow_on\":\r\n                        case \"slow_off\":\r\n                            break;\r\n\r\n                        // Do not handle followers_on/off here, listen to the ROOMSTATE notice instead as it returns the delay.\r\n                        case \"followers_on_zero\":\r\n                        case \"followers_on\":\r\n                        case \"followers_off\":\r\n                            break;\r\n\r\n                        // This room is now in r9k mode.\r\n                        case \"r9k_on\":\r\n                            this.log.info(`[${channel}] This room is now in r9k mode.`);\r\n                            this.emits([\"r9kmode\", \"r9kbeta\", \"_promiseR9kbeta\"], [[channel, true], [channel, true], [null]]);\r\n                            break;\r\n\r\n                        // This room is no longer in r9k mode.\r\n                        case \"r9k_off\":\r\n                            this.log.info(`[${channel}] This room is no longer in r9k mode.`);\r\n                            this.emits([\"r9kmode\", \"r9kbeta\", \"_promiseR9kbetaoff\"], [[channel, false], [channel, false], [null]]);\r\n                            break;\r\n\r\n                        // The moderators of this room are [...]\r\n                        case \"room_mods\":\r\n                            var splitted = msg.split(\":\");\r\n                            var mods = splitted[1].replace(/,/g, \"\").split(\":\").toString().toLowerCase().split(\" \");\r\n\r\n                            for(var i = mods.length - 1; i >= 0; i--) {\r\n                                if(mods[i] === \"\") {\r\n                                    mods.splice(i, 1);\r\n                                }\r\n                            }\r\n\r\n                            this.emits([\"_promiseMods\", \"mods\"], [[null, mods], [channel, mods]]);\r\n                            break;\r\n\r\n                        // There are no moderators for this room.\r\n                        case \"no_mods\":\r\n                            this.emit(\"_promiseMods\", null, []);\r\n                            break;\r\n\r\n                        // Channel is suspended..\r\n                        case \"msg_channel_suspended\":\r\n                            this.emits([\"notice\", \"_promiseJoin\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Ban command failed..\r\n                        case \"already_banned\":\r\n                        case \"bad_ban_admin\":\r\n                        case \"bad_ban_broadcaster\":\r\n                        case \"bad_ban_global_mod\":\r\n                        case \"bad_ban_self\":\r\n                        case \"bad_ban_staff\":\r\n                        case \"usage_ban\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseBan\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Ban command success..\r\n                        case \"ban_success\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseBan\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Clear command failed..\r\n                        case \"usage_clear\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseClear\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Mods command failed..\r\n                        case \"usage_mods\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseMods\"], [[channel, msgid, msg], [msgid, []]]);\r\n                            break;\r\n\r\n                        // Mod command success..\r\n                        case \"mod_success\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseMod\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Mod command failed..\r\n                        case \"usage_mod\":\r\n                        case \"bad_mod_banned\":\r\n                        case \"bad_mod_mod\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseMod\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Unmod command success..\r\n                        case \"unmod_success\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseUnmod\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Unmod command failed..\r\n                        case \"usage_unmod\":\r\n                        case \"bad_unmod_mod\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseUnmod\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Color command success..\r\n                        case \"color_changed\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseColor\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Color command failed..\r\n                        case \"usage_color\":\r\n                        case \"turbo_only_color\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseColor\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Commercial command success..\r\n                        case \"commercial_success\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseCommercial\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Commercial command failed..\r\n                        case \"usage_commercial\":\r\n                        case \"bad_commercial_error\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseCommercial\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Host command success..\r\n                        case \"hosts_remaining\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            var remainingHost = (!isNaN(msg.charAt(0)) ? msg.charAt(0) : 0);\r\n                            this.emits([\"notice\", \"_promiseHost\"], [[channel, msgid, msg], [null, ~~remainingHost]]);\r\n                            break;\r\n\r\n                        // Host command failed..\r\n                        case \"bad_host_hosting\":\r\n                        case \"bad_host_rate_exceeded\":\r\n                        case \"bad_host_error\":\r\n                        case \"usage_host\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseHost\"], [[channel, msgid, msg], [msgid, null]]);\r\n                            break;\r\n\r\n                        // r9kbeta command failed..\r\n                        case \"already_r9k_on\":\r\n                        case \"usage_r9k_on\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseR9kbeta\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // r9kbetaoff command failed..\r\n                        case \"already_r9k_off\":\r\n                        case \"usage_r9k_off\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseR9kbetaoff\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Timeout command success..\r\n                        case \"timeout_success\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseTimeout\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Subscribersoff command failed..\r\n                        case \"already_subs_off\":\r\n                        case \"usage_subs_off\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseSubscribersoff\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Subscribers command failed..\r\n                        case \"already_subs_on\":\r\n                        case \"usage_subs_on\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseSubscribers\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Emoteonlyoff command failed..\r\n                        case \"already_emote_only_off\":\r\n                        case \"usage_emote_only_off\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseEmoteonlyoff\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Emoteonly command failed..\r\n                        case \"already_emote_only_on\":\r\n                        case \"usage_emote_only_on\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseEmoteonly\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Slow command failed..\r\n                        case \"usage_slow_on\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseSlow\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Slowoff command failed..\r\n                        case \"usage_slow_off\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseSlowoff\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Timeout command failed..\r\n                        case \"usage_timeout\":\r\n                        case \"bad_timeout_admin\":\r\n                        case \"bad_timeout_broadcaster\":\r\n                        case \"bad_timeout_duration\":\r\n                        case \"bad_timeout_global_mod\":\r\n                        case \"bad_timeout_self\":\r\n                        case \"bad_timeout_staff\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseTimeout\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Unban command success..\r\n                        case \"unban_success\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseUnban\"], [[channel, msgid, msg], [null]]);\r\n                            break;\r\n\r\n                        // Unban command failed..\r\n                        case \"usage_unban\":\r\n                        case \"bad_unban_no_ban\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseUnban\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Unhost command failed..\r\n                        case \"usage_unhost\":\r\n                        case \"not_hosting\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseUnhost\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Whisper command failed..\r\n                        case \"whisper_invalid_login\":\r\n                        case \"whisper_invalid_self\":\r\n                        case \"whisper_limit_per_min\":\r\n                        case \"whisper_limit_per_sec\":\r\n                        case \"whisper_restricted_recipient\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\"notice\", \"_promiseWhisper\"], [[channel, msgid, msg], [msgid]]);\r\n                            break;\r\n\r\n                        // Permission error..\r\n                        case \"no_permission\":\r\n                        case \"msg_banned\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emits([\r\n                                \"notice\",\r\n                                \"_promiseBan\",\r\n                                \"_promiseClear\",\r\n                                \"_promiseUnban\",\r\n                                \"_promiseTimeout\",\r\n                                \"_promiseMod\",\r\n                                \"_promiseUnmod\",\r\n                                \"_promiseCommercial\",\r\n                                \"_promiseHost\",\r\n                                \"_promiseUnhost\",\r\n                                \"_promiseR9kbeta\",\r\n                                \"_promiseR9kbetaoff\",\r\n                                \"_promiseSlow\",\r\n                                \"_promiseSlowoff\",\r\n                                \"_promiseFollowers\",\r\n                                \"_promiseFollowersoff\",\r\n                                \"_promiseSubscribers\",\r\n                                \"_promiseSubscribersoff\",\r\n                                \"_promiseEmoteonly\",\r\n                                \"_promiseEmoteonlyoff\"\r\n                            ], [\r\n                                [channel, msgid, msg],\r\n                                [msgid], [msgid], [msgid], [msgid],\r\n                                [msgid], [msgid], [msgid], [msgid],\r\n                                [msgid], [msgid], [msgid], [msgid],\r\n                                [msgid], [msgid], [msgid], [msgid],\r\n                                [msgid], [msgid], [msgid]\r\n                            ]);\r\n                            break;\r\n\r\n                        // Unrecognized command..\r\n                        case \"unrecognized_cmd\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emit(\"notice\", channel, msgid, msg);\r\n\r\n                            if (msg.split(\" \").splice(-1)[0] === \"/w\") {\r\n                                this.log.warn(\"You must be connected to a group server to send or receive whispers.\");\r\n                            }\r\n                            break;\r\n\r\n                        // Send the following msg-ids to the notice event listener..\r\n                        case \"cmds_available\":\r\n                        case \"host_target_went_offline\":\r\n                        case \"msg_censored_broadcaster\":\r\n                        case \"msg_duplicate\":\r\n                        case \"msg_emoteonly\":\r\n                        case \"msg_verified_email\":\r\n                        case \"msg_ratelimit\":\r\n                        case \"msg_subsonly\":\r\n                        case \"msg_timedout\":\r\n                        case \"no_help\":\r\n                        case \"usage_disconnect\":\r\n                        case \"usage_help\":\r\n                        case \"usage_me\":\r\n                            this.log.info(`[${channel}] ${msg}`);\r\n                            this.emit(\"notice\", channel, msgid, msg);\r\n                            break;\r\n\r\n                        // Ignore this because we are already listening to HOSTTARGET..\r\n                        case \"host_on\":\r\n                        case \"host_off\":\r\n                            //\r\n                            break;\r\n\r\n                        default:\r\n                            if (msg.includes(\"Login unsuccessful\") || msg.includes(\"Login authentication failed\")) {\r\n                                this.wasCloseCalled = false;\r\n                                this.reconnect = false;\r\n                                this.reason = msg;\r\n                                this.log.error(this.reason);\r\n                                this.ws.close();\r\n                            }\r\n                            else if (msg.includes(\"Error logging in\") || msg.includes(\"Improperly formatted auth\")) {\r\n                                this.wasCloseCalled = false;\r\n                                this.reconnect = false;\r\n                                this.reason = msg;\r\n                                this.log.error(this.reason);\r\n                                this.ws.close();\r\n                            }\r\n                            else if (msg.includes(\"Invalid NICK\")) {\r\n                                this.wasCloseCalled = false;\r\n                                this.reconnect = false;\r\n                                this.reason = \"Invalid NICK.\";\r\n                                this.log.error(this.reason);\r\n                                this.ws.close();\r\n                            }\r\n                            else {\r\n                                this.log.warn(`Could not parse NOTICE from tmi.twitch.tv:\\n${JSON.stringify(message, null, 4)}`);\r\n                            }\r\n                            break;\r\n                    }\r\n                    break;\r\n\r\n                // Handle subanniversary / resub..\r\n                case \"USERNOTICE\":\r\n                    if (msgid === \"resub\") {\r\n                        var username = message.tags[\"display-name\"] || message.tags[\"login\"];\r\n                        var plan = message.tags[\"msg-param-sub-plan\"];\r\n                        var planName = _.replaceAll(_.get(message.tags[\"msg-param-sub-plan-name\"], null), {\r\n                            \"\\\\\\\\s\": \" \",\r\n                            \"\\\\\\\\:\": \";\",\r\n                            \"\\\\\\\\\\\\\\\\\": \"\\\\\",\r\n                            \"\\\\r\": \"\\r\",\r\n                            \"\\\\n\": \"\\n\"\r\n                        });\r\n                        var months = _.get(~~message.tags[\"msg-param-months\"], null);\r\n                        var prime = plan.includes(\"Prime\");\r\n                        var userstate = null;\r\n\r\n                        if (msg) {\r\n                            userstate = message.tags;\r\n                            userstate['message-type'] = 'resub';\r\n                        }\r\n\r\n                        this.emits([\"resub\", \"subanniversary\"], [\r\n                            [channel, username, months, msg, userstate, {prime, plan, planName}],\r\n                            [channel, username, months, msg, userstate, {prime, plan, planName}]\r\n                        ]);\r\n                    }\r\n\r\n                    // Handle sub\r\n                    else if (msgid == \"sub\") {\r\n                        var username = message.tags[\"display-name\"] || message.tags[\"login\"];\r\n                        var plan = message.tags[\"msg-param-sub-plan\"];\r\n                        var planName = _.replaceAll(_.get(message.tags[\"msg-param-sub-plan-name\"], null), {\r\n                            \"\\\\\\\\s\": \" \",\r\n                            \"\\\\\\\\:\": \";\",\r\n                            \"\\\\\\\\\\\\\\\\\": \"\\\\\",\r\n                            \"\\\\r\": \"\\r\",\r\n                            \"\\\\n\": \"\\n\"\r\n                        });\r\n                        var prime = plan.includes(\"Prime\");\r\n                        var userstate = null;\r\n\r\n                        if (msg) {\r\n                            userstate = message.tags;\r\n                            userstate['message-type'] = 'sub';\r\n                        }\r\n\r\n                        this.emit(\"subscription\", channel, username, {prime, plan, planName}, msg, userstate);\r\n                    }\r\n                    break;\r\n\r\n                // Channel is now hosting another channel or exited host mode..\r\n                case \"HOSTTARGET\":\r\n                    // Stopped hosting..\r\n                    if (msg.split(\" \")[0] === \"-\") {\r\n                        this.log.info(`[${channel}] Exited host mode.`);\r\n                        this.emits([\"unhost\", \"_promiseUnhost\"], [[channel, ~~msg.split(\" \")[1] || 0], [null]]);\r\n                    }\r\n                    // Now hosting..\r\n                    else {\r\n                        var viewers = ~~msg.split(\" \")[1] || 0;\r\n\r\n                        this.log.info(`[${channel}] Now hosting ${msg.split(\" \")[0]} for ${viewers} viewer(s).`);\r\n                        this.emit(\"hosting\", channel, msg.split(\" \")[0], viewers);\r\n                    }\r\n                    break;\r\n\r\n                // Someone has been timed out or chat has been cleared by a moderator..\r\n                case \"CLEARCHAT\":\r\n                    // User has been banned / timed out by a moderator..\r\n                    if (message.params.length > 1) {\r\n                        // Duration returns null if it's a ban, otherwise it's a timeout..\r\n                        var duration = _.get(message.tags[\"ban-duration\"], null);\r\n\r\n                        // Escaping values: http://ircv3.net/specs/core/message-tags-3.2.html#escaping-values\r\n                        var reason = _.replaceAll(_.get(message.tags[\"ban-reason\"], null), {\r\n                            \"\\\\\\\\s\": \" \",\r\n                            \"\\\\\\\\:\": \";\",\r\n                            \"\\\\\\\\\\\\\\\\\": \"\\\\\",\r\n                            \"\\\\r\": \"\\r\",\r\n                            \"\\\\n\": \"\\n\"\r\n                        });\r\n\r\n                        if (_.isNull(duration)) {\r\n                            this.log.info(`[${channel}] ${msg} has been banned. Reason: ${reason || \"n/a\"}`);\r\n                            this.emit(\"ban\", channel, msg, reason);\r\n                        } else {\r\n                            this.log.info(`[${channel}] ${msg} has been timed out for ${duration} seconds. Reason: ${reason || \"n/a\"}`);\r\n                            this.emit(\"timeout\", channel, msg, reason, ~~duration);\r\n                        }\r\n                    }\r\n                    // Chat was cleared by a moderator..\r\n                    else {\r\n                        this.log.info(`[${channel}] Chat was cleared by a moderator.`);\r\n                        this.emits([\"clearchat\", \"_promiseClear\"], [[channel], [null]]);\r\n                    }\r\n                    break;\r\n\r\n                // Received a reconnection request from the server..\r\n                case \"RECONNECT\":\r\n                    this.log.info(\"Received RECONNECT request from Twitch..\");\r\n                    this.log.info(`Disconnecting and reconnecting in ${Math.round(this.reconnectTimer / 1000)} seconds..`);\r\n                    this.disconnect();\r\n                    setTimeout(() => { this.connect(); }, this.reconnectTimer);\r\n                    break;\r\n\r\n                // Wrong cluster..\r\n                case \"SERVERCHANGE\":\r\n                    //\r\n                    break;\r\n\r\n                // Received when joining a channel and every time you send a PRIVMSG to a channel.\r\n                case \"USERSTATE\":\r\n                    message.tags.username = this.username;\r\n\r\n                    // Add the client to the moderators of this room..\r\n                    if (message.tags[\"user-type\"] === \"mod\") {\r\n                        if (!this.moderators[this.lastJoined]) { this.moderators[this.lastJoined] = []; }\r\n                        if (this.moderators[this.lastJoined].indexOf(this.username) < 0) { this.moderators[this.lastJoined].push(this.username); }\r\n                    }\r\n\r\n                    // Logged in and username doesn't start with justinfan..\r\n                    if (!_.isJustinfan(this.getUsername()) && !this.userstate[channel]) {\r\n                        this.userstate[channel] = message.tags;\r\n                        this.lastJoined = channel;\r\n                        this.channels.push(channel);\r\n                        this.log.info(`Joined ${channel}`);\r\n                        this.emit(\"join\", channel, _.username(this.getUsername()), true);\r\n                    }\r\n\r\n                    // Emote-sets has changed, update it..\r\n                    if (message.tags[\"emote-sets\"] !== this.emotes) {\r\n                        this._updateEmoteset(message.tags[\"emote-sets\"]);\r\n                    }\r\n\r\n                    this.userstate[channel] = message.tags;\r\n                    break;\r\n\r\n                // Describe non-channel-specific state informations..\r\n                case \"GLOBALUSERSTATE\":\r\n                    this.globaluserstate = message.tags;\r\n\r\n                    // Received emote-sets..\r\n                    if (typeof message.tags[\"emote-sets\"] !== \"undefined\") {\r\n                        this._updateEmoteset(message.tags[\"emote-sets\"]);\r\n                    }\r\n                    break;\r\n\r\n                // Received when joining a channel and every time one of the chat room settings, like slow mode, change.\r\n                // The message on join contains all room settings.\r\n                case \"ROOMSTATE\":\r\n                    // We use this notice to know if we successfully joined a channel..\r\n                    if (_.channel(this.lastJoined) === _.channel(message.params[0])) { this.emit(\"_promiseJoin\", null); }\r\n\r\n                    // Provide the channel name in the tags before emitting it..\r\n                    message.tags.channel = _.channel(message.params[0]);\r\n                    this.emit(\"roomstate\", _.channel(message.params[0]), message.tags);\r\n\r\n                    // Handle slow mode here instead of the slow_on/off notice..\r\n                    // This room is now in slow mode. You may send messages every slow_duration seconds.\r\n                    if (message.tags.hasOwnProperty(\"slow\") && !message.tags.hasOwnProperty(\"subs-only\")) {\r\n                        if (typeof message.tags.slow === \"boolean\") {\r\n                            this.log.info(`[${channel}] This room is no longer in slow mode.`);\r\n                            this.emits([\"slow\", \"slowmode\", \"_promiseSlowoff\"], [[channel, false, 0], [channel, false, 0], [null]]);\r\n                        } else {\r\n                            this.log.info(`[${channel}] This room is now in slow mode.`);\r\n                            this.emits([\"slow\", \"slowmode\", \"_promiseSlow\"], [[channel, true, ~~message.tags.slow], [channel, true, ~~message.tags.slow], [null]]);\r\n                        }\r\n                    }\r\n\r\n                    // Handle followers only mode here instead of the followers_on/off notice..\r\n                    // This room is now in follower-only mode.\r\n                    // This room is now in <duration> followers-only mode.\r\n                    // This room is no longer in followers-only mode.\r\n                    // duration is in minutes (string)\r\n                    // -1 when /followersoff (string)\r\n                    // false when /followers with no duration (boolean)\r\n                    if (message.tags.hasOwnProperty(\"followers-only\") && !message.tags.hasOwnProperty(\"subs-only\")) {\r\n                        if (message.tags[\"followers-only\"] === \"-1\") {\r\n                            this.log.info(`[${channel}] This room is no longer in followers-only mode.`);\r\n                            this.emits([\"followersonly\", \"followersmode\", \"_promiseFollowersoff\"], [[channel, false, 0], [channel, false, 0], [null]]);\r\n                        } else {\r\n                            var minutes = ~~message.tags[\"followers-only\"];\r\n                            this.log.info(`[${channel}] This room is now in follower-only mode.`);\r\n                            this.emits([\"followersonly\", \"followersmode\", \"_promiseFollowers\"], [[channel, true, minutes], [channel, true, minutes], [null]]);\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    this.log.warn(`Could not parse message from tmi.twitch.tv:\\n${JSON.stringify(message, null, 4)}`);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Messages from jtv..\r\n        else if (message.prefix === \"jtv\") {\r\n            switch(message.command) {\r\n                case \"MODE\":\r\n                    if (msg === \"+o\") {\r\n                        // Add username to the moderators..\r\n                        if (!this.moderators[channel]) { this.moderators[channel] = []; }\r\n                        if (this.moderators[channel].indexOf(message.params[2]) < 0) { this.moderators[channel].push(message.params[2]); }\r\n\r\n                        this.emit(\"mod\", channel, message.params[2]);\r\n                    }\r\n                    else if (msg === \"-o\") {\r\n                        // Remove username from the moderators..\r\n                        if (!this.moderators[channel]) { this.moderators[channel] = []; }\r\n                        this.moderators[channel].filter((value) => { return value != message.params[2]; });\r\n\r\n                        this.emit(\"unmod\", channel, message.params[2]);\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    this.log.warn(`Could not parse message from jtv:\\n${JSON.stringify(message, null, 4)}`);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        // Anything else..\r\n        else {\r\n            switch(message.command) {\r\n                case \"353\":\r\n                    this.emit(\"names\", message.params[2], message.params[3].split(\" \"));\r\n                    break;\r\n\r\n                case \"366\":\r\n                    break;\r\n\r\n                // Someone has joined the channel..\r\n                case \"JOIN\":\r\n                    // Joined a channel as a justinfan (anonymous) user..\r\n                    if (_.isJustinfan(this.getUsername()) && this.username === message.prefix.split(\"!\")[0]) {\r\n                        this.lastJoined = channel;\r\n                        this.channels.push(channel);\r\n                        this.log.info(`Joined ${channel}`);\r\n                        this.emit(\"join\", channel, message.prefix.split(\"!\")[0], true);\r\n                    }\r\n\r\n                    // Someone else joined the channel, just emit the join event..\r\n                    if (this.username !== message.prefix.split(\"!\")[0]) {\r\n                        this.emit(\"join\", channel, message.prefix.split(\"!\")[0], false);\r\n                    }\r\n                    break;\r\n\r\n                // Someone has left the channel..\r\n                case \"PART\":\r\n                    var isSelf = false;\r\n                    // Client a channel..\r\n                    if (this.username === message.prefix.split(\"!\")[0]) {\r\n                        isSelf = true;\r\n                        if (this.userstate[channel]) { delete this.userstate[channel]; }\r\n\r\n                        var index = this.channels.indexOf(channel);\r\n                        if (index !== -1) { this.channels.splice(index, 1); }\r\n\r\n                        var index = this.opts.channels.indexOf(channel);\r\n                        if (index !== -1) { this.opts.channels.splice(index, 1); }\r\n\r\n                        this.log.info(`Left ${channel}`);\r\n                        this.emit(\"_promisePart\", null);\r\n                    }\r\n\r\n                    // Client or someone else left the channel, emit the part event..\r\n                    this.emit(\"part\", channel, message.prefix.split(\"!\")[0], isSelf);\r\n                    break;\r\n\r\n                // Received a whisper..\r\n                case \"WHISPER\":\r\n                    this.log.info(`[WHISPER] <${message.prefix.split(\"!\")[0]}>: ${msg}`);\r\n\r\n                    // Update the tags to provide the username..\r\n                    if (!message.tags.hasOwnProperty(\"username\")) { message.tags.username = message.prefix.split(\"!\")[0]; }\r\n                    message.tags[\"message-type\"] = \"whisper\";\r\n\r\n                    var from = _.channel(message.tags.username);\r\n                    // Emit for both, whisper and message..\r\n                    this.emits([\"whisper\", \"message\"], [\r\n                        [from, message.tags, msg, false],\r\n                        [from, message.tags, msg, false]\r\n                    ]);\r\n                    break;\r\n\r\n                case \"PRIVMSG\":\r\n                    // Add username (lowercase) to the tags..\r\n                    message.tags.username = message.prefix.split(\"!\")[0];\r\n\r\n                    // Message from JTV..\r\n                    if (message.tags.username === \"jtv\") {\r\n                        // Someone is hosting the channel and the message contains how many viewers..\r\n                        if (msg.includes(\"hosting you for\")) {\r\n                            var count = _.extractNumber(msg);\r\n\r\n                            this.emit(\"hosted\", channel, _.username(msg.split(\" \")[0]), count, msg.includes(\"auto\"));\r\n                        }\r\n\r\n                        // Some is hosting the channel, but no viewer(s) count provided in the message..\r\n                        else if (msg.includes(\"hosting you\")) {\r\n                            this.emit(\"hosted\", channel, _.username(msg.split(\" \")[0]), 0, msg.includes(\"auto\"));\r\n                        }\r\n                    }\r\n\r\n                    else {\r\n                        // Message is an action (/me <message>)..\r\n                        if (msg.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)) {\r\n                            message.tags[\"message-type\"] = \"action\";\r\n                            this.log.info(`[${channel}] *<${message.tags.username}>: ${msg.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)[1]}`);\r\n                            this.emits([\"action\", \"message\"], [\r\n                                [channel, message.tags, msg.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)[1], false],\r\n                                [channel, message.tags, msg.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)[1], false]\r\n                            ]);\r\n                        }\r\n                        else {\r\n                            if (message.tags.hasOwnProperty(\"bits\")) {\r\n                                this.emit(\"cheer\", channel, message.tags, msg);\r\n                            }\r\n\r\n                            // Message is a regular chat message..\r\n                            else {\r\n                                message.tags[\"message-type\"] = \"chat\";\r\n                                this.log.info(`[${channel}] <${message.tags.username}>: ${msg}`);\r\n\r\n                                this.emits([\"chat\", \"message\"], [\r\n                                    [channel, message.tags, msg, false],\r\n                                    [channel, message.tags, msg, false]\r\n                                ]);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n\r\n                default:\r\n                    this.log.warn(`Could not parse message:\\n${JSON.stringify(message, null, 4)}`);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n// Connect to server..\r\nclient.prototype.connect = function connect() {\r\n    return new Promise((resolve, reject) => {\r\n        this.server = _.get(this.opts.connection.server, \"irc-ws.chat.twitch.tv\");\r\n        this.port = _.get(this.opts.connection.port, 80);\r\n\r\n        // Override port if using a secure connection..\r\n        if (this.secure) { this.port = 443; }\r\n        if (this.port === 443) { this.secure = true; }\r\n\r\n        this.reconnectTimer = this.reconnectTimer * this.reconnectDecay;\r\n        if (this.reconnectTimer >= this.maxReconnectInterval) {\r\n            this.reconnectTimer = this.maxReconnectInterval;\r\n        }\r\n\r\n        // Connect to server from configuration..\r\n        this._openConnection();\r\n        this.once(\"_promiseConnect\", (err) => {\r\n            if (!err) { resolve([this.server, ~~this.port]); }\r\n            else { reject(err); }\r\n        });\r\n    });\r\n};\r\n\r\n// Open a connection..\r\nclient.prototype._openConnection = function _openConnection() {\r\n    this.ws = new ws(`${this.secure ? \"wss\" : \"ws\"}://${this.server}:${this.port}/`, \"irc\");\r\n\r\n    this.ws.onmessage = this._onMessage.bind(this);\r\n    this.ws.onerror = this._onError.bind(this);\r\n    this.ws.onclose = this._onClose.bind(this);\r\n    this.ws.onopen = this._onOpen.bind(this);\r\n};\r\n\r\n// Called when the WebSocket connection's readyState changes to OPEN.\r\n// Indicates that the connection is ready to send and receive data..\r\nclient.prototype._onOpen = function _onOpen() {\r\n    if (!_.isNull(this.ws) && this.ws.readyState === 1) {\r\n        // Emitting \"connecting\" event..\r\n        this.log.info(`Connecting to ${this.server} on port ${this.port}..`);\r\n        this.emit(\"connecting\", this.server, ~~this.port);\r\n\r\n        this.username = _.get(this.opts.identity.username, _.justinfan());\r\n        this.password = _.password(_.get(this.opts.identity.password, \"SCHMOOPIIE\"));\r\n\r\n        // Emitting \"logon\" event..\r\n        this.log.info(\"Sending authentication to server..\");\r\n        this.emit(\"logon\");\r\n\r\n        // Authentication..\r\n        this.ws.send(\"CAP REQ :twitch.tv/tags twitch.tv/commands twitch.tv/membership\");\r\n        this.ws.send(`PASS ${this.password}`);\r\n        this.ws.send(`NICK ${this.username}`);\r\n        this.ws.send(`USER ${this.username} 8 * :${this.username}`);\r\n    }\r\n};\r\n\r\n// Called when a message is received from the server..\r\nclient.prototype._onMessage = function _onMessage(event) {\r\n    var parts = event.data.split(\"\\r\\n\");\r\n\r\n    parts.forEach((str) => {\r\n        if (!_.isNull(str)) { this.handleMessage(parse.msg(str)); }\r\n    });\r\n};\r\n\r\n// Called when an error occurs..\r\nclient.prototype._onError = function _onError() {\r\n    this.moderators = {};\r\n    this.userstate = {};\r\n    this.globaluserstate = {};\r\n\r\n    // Stop the internal ping timeout check interval..\r\n    clearInterval(this.pingLoop);\r\n    clearTimeout(this.pingTimeout);\r\n\r\n    this.reason = !_.isNull(this.ws) ? \"Unable to connect.\" : \"Connection closed.\";\r\n\r\n    this.emits([\"_promiseConnect\", \"disconnected\"], [[this.reason], [this.reason]]);\r\n\r\n    // Reconnect to server..\r\n    if (this.reconnect && this.reconnections === this.maxReconnectAttempts) {\r\n        this.emit(\"maxreconnect\");\r\n        this.log.error(\"Maximum reconnection attempts reached.\");\r\n    }\r\n    if (this.reconnect && !this.reconnecting && this.reconnections <= this.maxReconnectAttempts-1) {\r\n        this.reconnecting = true;\r\n        this.reconnections = this.reconnections+1;\r\n        this.log.error(`Reconnecting in ${Math.round(this.reconnectTimer / 1000)} seconds..`);\r\n        this.emit(\"reconnect\");\r\n        setTimeout(() => { this.reconnecting = false; this.connect(); }, this.reconnectTimer);\r\n    }\r\n\r\n    this.ws = null;\r\n};\r\n\r\n// Called when the WebSocket connection's readyState changes to CLOSED..\r\nclient.prototype._onClose = function _onClose() {\r\n    this.moderators = {};\r\n    this.userstate = {};\r\n    this.globaluserstate = {};\r\n\r\n    // Stop the internal ping timeout check interval..\r\n    clearInterval(this.pingLoop);\r\n    clearTimeout(this.pingTimeout);\r\n\r\n    // User called .disconnect(), don't try to reconnect.\r\n    if (this.wasCloseCalled) {\r\n        this.wasCloseCalled = false;\r\n        this.reason = \"Connection closed.\";\r\n        this.log.info(this.reason);\r\n        this.emits([\"_promiseConnect\", \"_promiseDisconnect\", \"disconnected\"], [[this.reason], [null], [this.reason]]);\r\n    }\r\n    // Got disconnected from server..\r\n    else {\r\n        this.emits([\"_promiseConnect\", \"disconnected\"], [[this.reason], [this.reason]]);\r\n\r\n        // Reconnect to server..\r\n        if (this.reconnect && this.reconnections === this.maxReconnectAttempts) {\r\n            this.emit(\"maxreconnect\");\r\n            this.log.error(\"Maximum reconnection attempts reached.\");\r\n        }\r\n        if (this.reconnect && !this.reconnecting && this.reconnections <= this.maxReconnectAttempts-1) {\r\n            this.reconnecting = true;\r\n            this.reconnections = this.reconnections+1;\r\n            this.log.error(`Could not connect to server. Reconnecting in ${Math.round(this.reconnectTimer / 1000)} seconds..`);\r\n            this.emit(\"reconnect\");\r\n            setTimeout(() => { this.reconnecting = false; this.connect(); }, this.reconnectTimer);\r\n        }\r\n    }\r\n\r\n    this.ws = null;\r\n};\r\n\r\n// Minimum of 600ms for command promises, if current latency exceeds, add 100ms to it to make sure it doesn't get timed out..\r\nclient.prototype._getPromiseDelay = function _getPromiseDelay() {\r\n    if (this.currentLatency <= 600) { return 600; }\r\n    else { return this.currentLatency + 100; }\r\n};\r\n\r\n// Send command to server or channel..\r\nclient.prototype._sendCommand = function _sendCommand(delay, channel, command, fn) {\r\n    // Race promise against delay..\r\n    return new Promise((resolve, reject) => {\r\n        _.promiseDelay(delay).then(() => { reject(\"No response from Twitch.\"); });\r\n\r\n        // Make sure the socket is opened..\r\n        if (!_.isNull(this.ws) && this.ws.readyState !== 2 && this.ws.readyState !== 3) {\r\n            // Executing a command on a channel..\r\n            if (!_.isNull(channel)) {\r\n                this.log.info(`[${_.channel(channel)}] Executing command: ${command}`);\r\n                this.ws.send(`PRIVMSG ${_.channel(channel)} :${command}`);\r\n            }\r\n\r\n            // Executing a raw command..\r\n            else {\r\n                this.log.info(`Executing command: ${command}`);\r\n                this.ws.send(command);\r\n            }\r\n            fn(resolve, reject);\r\n        }\r\n\r\n        // Disconnected from server..\r\n        else { reject(\"Not connected to server.\"); }\r\n    });\r\n};\r\n\r\n// Send a message to channel..\r\nclient.prototype._sendMessage = function _sendMessage(delay, channel, message, fn) {\r\n    // Promise a result..\r\n    return new Promise((resolve, reject) => {\r\n        // Make sure the socket is opened and not logged in as a justinfan user..\r\n        if (!_.isNull(this.ws) && this.ws.readyState !== 2 && this.ws.readyState !== 3 && !_.isJustinfan(this.getUsername())) {\r\n            if (!this.userstate[_.channel(channel)]) { this.userstate[_.channel(channel)] = {} }\r\n\r\n            // Split long lines otherwise they will be eaten by the server..\r\n            if (message.length >= 500) {\r\n                var msg = _.splitLine(message, 500);\r\n                message = msg[0];\r\n\r\n                setTimeout(() => {\r\n                    this._sendMessage(delay, channel, msg[1], () => {});\r\n                }, 350);\r\n            }\r\n\r\n            this.ws.send(`PRIVMSG ${_.channel(channel)} :${message}`);\r\n\r\n            var emotes = {};\r\n\r\n            // Parse regex and string emotes..\r\n            Object.keys(this.emotesets).forEach((id) => {\r\n                this.emotesets[id].forEach(function(emote) {\r\n                    if (_.isRegex(emote.code)) { return parse.emoteRegex(message, emote.code, emote.id, emotes); }\r\n                    parse.emoteString(message, emote.code, emote.id, emotes);\r\n                });\r\n            });\r\n\r\n            // Merge userstate with parsed emotes..\r\n            var userstate = _.merge(this.userstate[_.channel(channel)], parse.emotes({ emotes: parse.transformEmotes(emotes) || null }));\r\n\r\n            // Message is an action (/me <message>)..\r\n            if (message.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)) {\r\n                userstate[\"message-type\"] = \"action\";\r\n                this.log.info(`[${_.channel(channel)}] *<${this.getUsername()}>: ${message.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)[1]}`);\r\n                this.emits([\"action\", \"message\"], [\r\n                    [_.channel(channel), userstate, message.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)[1], true],\r\n                    [_.channel(channel), userstate, message.match(/^\\u0001ACTION ([^\\u0001]+)\\u0001$/)[1], true]\r\n                ]);\r\n            }\r\n\r\n            // Message is a regular chat message..\r\n            else {\r\n                userstate[\"message-type\"] = \"chat\";\r\n                this.log.info(`[${_.channel(channel)}] <${this.getUsername()}>: ${message}`);\r\n                this.emits([\"chat\", \"message\"], [\r\n                    [_.channel(channel), userstate, message, true],\r\n                    [_.channel(channel), userstate, message, true]\r\n                ]);\r\n            }\r\n            fn(resolve, reject);\r\n        } else {\r\n            reject(\"Not connected to server.\");\r\n        }\r\n    });\r\n};\r\n\r\n// Grab the emote-sets object from the API..\r\nclient.prototype._updateEmoteset = function _updateEmoteset(sets) {\r\n    this.emotes = sets;\r\n\r\n    this.api({\r\n        url: `/chat/emoticon_images?emotesets=${sets}`,\r\n        headers: {\r\n            \"Authorization\": `OAuth ${_.password(_.get(this.opts.identity.password, \"\")).replace(\"oauth:\", \"\")}`,\r\n            \"Client-ID\": this.clientId\r\n        }\r\n    }, (err, res, body) => {\r\n        if (!err) {\r\n            this.emotesets = body[\"emoticon_sets\"] || {};\r\n            return this.emit(\"emotesets\", sets, this.emotesets);\r\n        }\r\n        setTimeout(() => { this._updateEmoteset(sets); }, 60000);\r\n    });\r\n};\r\n\r\n// Get current username..\r\nclient.prototype.getUsername = function getUsername() {\r\n    return this.username;\r\n};\r\n\r\n// Get current options..\r\nclient.prototype.getOptions = function getOptions() {\r\n    return this.opts;\r\n};\r\n\r\n// Get current channels..\r\nclient.prototype.getChannels = function getChannels() {\r\n    return this.channels;\r\n};\r\n\r\n// Check if username is a moderator on a channel..\r\nclient.prototype.isMod = function isMod(channel, username) {\r\n    if (!this.moderators[_.channel(channel)]) { this.moderators[_.channel(channel)] = []; }\r\n    if (this.moderators[_.channel(channel)].indexOf(_.username(username)) >= 0) {\r\n        return true;\r\n    }\r\n    return false;\r\n};\r\n\r\n// Get readyState..\r\nclient.prototype.readyState = function readyState() {\r\n    if (_.isNull(this.ws)) { return \"CLOSED\"; }\r\n    return [\"CONNECTING\", \"OPEN\", \"CLOSING\", \"CLOSED\"][this.ws.readyState];\r\n};\r\n\r\n// Disconnect from server..\r\nclient.prototype.disconnect = function disconnect() {\r\n    return new Promise((resolve, reject) => {\r\n        if (!_.isNull(this.ws) && this.ws.readyState !== 3) {\r\n            this.wasCloseCalled = true;\r\n            this.log.info(\"Disconnecting from server..\");\r\n            this.ws.close();\r\n            this.once(\"_promiseDisconnect\", () => { resolve([this.server, ~~this.port]); });\r\n        } else {\r\n            this.log.error(\"Cannot disconnect from server. Socket is not opened or connection is already closing.\");\r\n            reject(\"Cannot disconnect from server. Socket is not opened or connection is already closing.\");\r\n        }\r\n    });\r\n};\r\n\r\nclient.prototype.utils = {\r\n    levenshtein: function levenshtein(s1, s2, caseSensitive) {\r\n        var cost_ins = 1;\r\n        var cost_rep = 1;\r\n        var cost_del = 1;\r\n        caseSensitive = _.get(caseSensitive, false);\r\n\r\n        if (!caseSensitive) {\r\n            s1 = s1.toLowerCase();\r\n            s2 = s2.toLowerCase();\r\n        }\r\n\r\n        if (s1 == s2) { return 0; }\r\n\r\n        var l1 = s1.length;\r\n        var l2 = s2.length;\r\n\r\n        if (l1 === 0) { return l2 * cost_ins; }\r\n        if (l2 === 0) { return l1 * cost_del; }\r\n\r\n        var split = false;\r\n        try {\r\n            split = !(\"0\")[0];\r\n        } catch (e) {\r\n            split = true;\r\n        }\r\n        if (split) {\r\n            s1 = s1.split(\"\");\r\n            s2 = s2.split(\"\");\r\n        }\r\n\r\n        var p1 = new Array(l2 + 1);\r\n        var p2 = new Array(l2 + 1);\r\n\r\n        var i1, i2, c0, c1, c2, tmp;\r\n\r\n        for (i2 = 0; i2 <= l2; i2++) {\r\n            p1[i2] = i2 * cost_ins;\r\n        }\r\n\r\n        for (i1 = 0; i1 < l1; i1++) {\r\n            p2[0] = p1[0] + cost_del;\r\n\r\n            for (i2 = 0; i2 < l2; i2++) {\r\n                c0 = p1[i2] + ((s1[i1] == s2[i2]) ? 0 : cost_rep);\r\n                c1 = p1[i2 + 1] + cost_del;\r\n\r\n                if (c1 < c0) {\r\n                    c0 = c1;\r\n                }\r\n\r\n                c2 = p2[i2] + cost_ins;\r\n\r\n                if (c2 < c0) {\r\n                    c0 = c2;\r\n                }\r\n\r\n                p2[i2 + 1] = c0;\r\n            }\r\n\r\n            tmp = p1;\r\n            p1 = p2;\r\n            p2 = tmp;\r\n        }\r\n\r\n        c0 = p1[l2];\r\n\r\n        return c0;\r\n    },\r\n    raffle: {\r\n        init: function init(channel) {\r\n            if (!this.raffleChannels) { this.raffleChannels = {}; }\r\n            if (!this.raffleChannels[_.channel(channel)]) { this.raffleChannels[_.channel(channel)] = []; }\r\n        },\r\n        enter: function enter(channel, username) {\r\n            this.init(channel);\r\n            this.raffleChannels[_.channel(channel)].push(username.toLowerCase());\r\n        },\r\n        leave: function leave(channel, username) {\r\n            this.init(channel);\r\n            var index = this.raffleChannels[_.channel(channel)].indexOf(_.username(username));\r\n            if (index >= 0) {\r\n                this.raffleChannels[_.channel(channel)].splice(index, 1);\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        pick: function pick(channel) {\r\n            this.init(channel);\r\n            var count = this.raffleChannels[_.channel(channel)].length;\r\n            if (count >= 1) {\r\n                return this.raffleChannels[_.channel(channel)][Math.floor((Math.random() * count))];\r\n            }\r\n            return null;\r\n        },\r\n        reset: function reset(channel) {\r\n            this.init(channel);\r\n            this.raffleChannels[_.channel(channel)] = [];\r\n        },\r\n        count: function count(channel) {\r\n            this.init(channel);\r\n            if (this.raffleChannels[_.channel(channel)]) {\r\n                return this.raffleChannels[_.channel(channel)].length;\r\n            }\r\n            return 0;\r\n        },\r\n        isParticipating: function isParticipating(channel, username) {\r\n            this.init(channel);\r\n            if (this.raffleChannels[_.channel(channel)].indexOf(_.username(username)) >= 0) {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    },\r\n    symbols: function symbols(line) {\r\n        var count = 0;\r\n        for (var i = 0; i < line.length; i++) {\r\n            var charCode = line.substring(i, i+1).charCodeAt(0);\r\n            if ((charCode <= 30 || charCode >= 127) || charCode === 65533) {\r\n                count++;\r\n            }\r\n        }\r\n        return Math.ceil((count / line.length) * 100) / 100;\r\n    },\r\n    uppercase: function uppercase(line) {\r\n        var chars = line.length;\r\n        var u_let = line.match(/[A-Z]/g);\r\n        if (!_.isNull(u_let)) {\r\n            return (u_let.length / chars);\r\n        }\r\n        return 0;\r\n    }\r\n};\r\n\r\n// Expose everything, for browser and Node..\r\nif (typeof module !== \"undefined\" && module.exports) {\r\n    module.exports = client;\r\n}\r\nif (typeof window !== \"undefined\") {\r\n    window.tmi = {};\r\n    window.tmi.client = client;\r\n}\r\n"},"hash":"32254598245c389eaa23cd62c51d3859"}